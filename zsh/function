#!/bin/zsh
#
# reload zshrc
function src() {
    autoload -U zrecompile
    [[ -f ~/.zshrc ]] && zrecompile -p ~/.zshrc
    for i in "$(find ~/.zsh/ -type f)"; do
        [[ -f $i ]] && zrecompile -p $i
        [[ -f $i.zwc.old ]] && rm -f $i.zwc.old
    done
    [[ -f ~/.zcompdump ]] && zrecompile -p ~/.zcompdump
    [[ -f ~/.zcompdump ]] && zrecompile -p ~/.zcompdump
    [[ -f ~/.zshrc.zwc.old ]] && rm -f ~/.zshrc.zwc.old
    [[ -f ~/.zcompdump.zwc.old ]] && rm -f ~/.zcompdump.zwc.old
    source ~/.zshrc
}


#kill emacs daemon
function ked() {
    echo "trying to kill emacs"
    pgrep -u $USER "emacs" > /dev/null
    RETVAL=$?
    if [ $RETVAL -eq 0 ]; then
        echo "killing emacs on " `date` >> ~/.emacs.d/emacs-server.log
        emacsclient -nw -e '(kill-emacs)'
    else
        echo "no emacs-daemon is running"
    fi
}

# update emacs
function eup()
{
    (cd ~gr/emacs
     gpl
     compile_emacs)
}
function started() {
    if [ $# -gt 0 ]; then
        if [ "$1" = "-f" ]; then
            echo "$embin --daemon"
            $embin --daemon
            return
        fi
    fi

    pgrep -u $USER "emacs" > /dev/null
    RETVAL=$?
    if [ $RETVAL -eq 0 ]; then
        echo "emacs-daemon already running"
    else
        echo "$embin --daemon"
        $embin --daemon
    fi
}

function cenvdir() {
    echo $HOME/miniconda/envs/$CONDA_DEFAULT_ENV
}
function switchcurenv() {
    cd `cenvdir`
}

function env3k() {
    enconda
    workon py3k
    export PYTHONPATH=~/local/lib/python3.4/site-packages:$PYTHONPATH
    export LD_LIBRARY_PATH=~/local/lib:$LD_LIBRARY_PATH
}

function melmacs() {
    emacs -Q --eval "(add-to-list 'package-archives '(\"melpa\" . \"http://melpa.milkbox.net/packages/\") t)"
}

function enconda() {
    type conda &>/dev/null && return
    perl -e 'exit(!(grep(m{^$ENV{HOME}/miniconda/bin$},split(":", $ENV{PATH}))) > 0)' && return
    export PATH=$HOME/miniconda/bin:$PATH
}

function dired() {
    if [ $# -gt 0 ]; then
        dirname="$1"
    else
        dirname="$HOME"
    fi
    emacsclient -c -eval "(dired \"$dirname\")"
}

_emacs_setup() {
    local name=$1
    echo $name
    if [ -L ~/.emacs.d ]; then
        unlink ~/.emacs.d
    fi
    if [ -L ~/.emacs ]; then
        unlink ~/.emacs
    fi
    if [ -e ~/.emacs.d ]; then
        echo "deleting .emacs.d"
        rm -rf ~/.emacs.d
    fi

    if [ -e ~dotf/$name ]; then
        echo ln -s ~dotf/$name ~/.emacs
        ln -s ~dotf/$name ~/.emacs
    fi
    echo ln -s ~dotf/${name}.d ~/.emacs.d
    ln -s ~dotf/${name}.d ~/.emacs.d
}

function emacs_melpa_setup() {
    _emacs_setup "emacs_with_melpa"
}

function emacs_comp_setup() {
    _emacs_setup "emacs_with_company"
}

function emacs_test_setup() {
    _emacs_setup "emacs_with_test"
}

function emacs_elget_setup() {
    _emacs_setup "emacs_with_elget"
}

function emacs_graphene_setup() {
    _emacs_setup "emacs_with_graphene"
}

function emacs_std_setup() {
    _emacs_setup "emacs"
}

function add-alias() {
    local name=$1 value="$2"
    echo "alias $name='$value'" >> ~/.zsh/alias
    eval "alias $name='$value'"
    alias $name
}

#running process search
function psea() {
    local pregex=$1
    ps ax | grep -i $pregex
}

function concatpdf() {
    echo "saving concatenated pdf to output.pdf"
    /bin/gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=output.pdf $*
}


function GG() { grep -RiI --exclude-dir=.svn  --exclude-dir=.git $* * }

# git functions
function ga() { git add $* }
function gb() { git branch $* }
function gf() { git fetch $* }
function gd() { git diff --ignore-submodules $* }
function gg() { git grep $* }
function glol() { git lola $* }
function gk() { gitk --all $* & }
function gl() { git log $* }
function gs() { git status --ignore-submodules $* }
function gsvr() { git svn rebase $* }
function gp() { git push $* }
function gc() { git commit -m "$*" }
function gcl() { git clone "$*" }
function gpl() { git pull $* }
function gps() { git push $* }
function gsr() { git svn rebase $* }
function gri() { git rebase -i $* }
function gf() { git fetch $* }
function gco() {
    if [ -z "$1" ]; then
        git checkout master
    else
        git checkout $1
    fi
}
function gcf() {
    git checkout -f $*
}

function gpr() { git pull --rebase $* }

function ginf() {
    cat "$(git rev-parse --show-toplevel)"/.git/config
}



function sco() {
    args=""
    if [[ $# -ge 1 ]]; then
        if [[ $1 == 'trunk' ]]; then
            NLDIR=`pwd`/../NetLib
        else
            print "unknown type", $1
            return 1
        fi
        if [[ $# -ge 2 ]]; then
           args=$2
        fi
    else
        NLDIR=`pwd`/../NetLib
    fi

    echo NLDIR is $NLDIR
    if [ ! -e $NLDIR ]; then
        echo "$NLDIR does not exist (wrong directory ??)"
    fi
    echo executing
    echo scons Arch=arch-pc Patch=0 NetLib=$NLDIR $args
    scons Arch=arch-pc Patch=0 NetLib=$NLDIR $args
}

function scocf() {
    args=""
    if [[ $# -ge 1 ]]; then
        if [[ $1 == 'trunk' ]]; then
            NLDIR=`pwd`/../NetLib
        else
            print "unknown type", $1
            return 1
        fi
        if [[ $# -ge 2 ]]; then
           args=$2
        fi
    else
        NLDIR=`pwd`/../NetLib
    fi

    echo NLDIR is $NLDIR
    if [ ! -e $NLDIR ]; then
        echo "$NLDIR does not exist (wrong directory ??)"
    fi
    echo executing
    echo scons Arch=arch-cf Patch=0 NetLib=$NLDIR $args
    scons Arch=arch-cf Patch=0 NetLib=$NLDIR $args
}


function makecf {
    (cd ${CFBD} && make)
}

function laserscp() {
    remotedir="/home/thomas/public_html/laser"
    remotehost="thomas@opentech.meinserver.at"
    flist=$@
    if [[ $# -gt 1 ]]; then
        # echo more than one arg:  $#
        if [[ ! -e $@[$#] ]]; then
            # echo last arg $@[$#] does not exist
            # echo strip it from arglist
            strippedlen=$((${#@}-1))
            # echo $strippedlen
            # echo ${@:1:${strippedlen}}
            flist=${@:1:${strippedlen}}
            remotedir=$remotedir/$@[${#@}]
            echo $remotehost "mkdir -p $remotedir"
            ssh $remotehost "mkdir -p $remotedir"
        else
            # echo $@[$#] exists
        fi
    fi

    # for i in {1..${#@}}; do
    #     echo $i, $@[$i]
    # done
    echo secure copy : $flist
    echo to: $remotehost:$remotedir
    scp $flist $remotehost:$remotedir/
}

function diplomscp() {
    remotedir="/home/thomas/public_html/diplom"
    remotehost="thomas@opentech.meinserver.at"
    flist=$@
    if [[ $# -gt 1 ]]; then
        # echo more than one arg:  $#
        if [[ ! -e $@[$#] ]]; then
            # echo last arg $@[$#] does not exist
            # echo strip it from arglist
            strippedlen=$((${#@}-1))
            # echo $strippedlen
            # echo ${@:1:${strippedlen}}
            flist=${@:1:${strippedlen}}
            remotedir=$remotedir/$@[${#@}]
            echo $remotehost "mkdir -p $remotedir"
            ssh $remotehost "mkdir -p $remotedir"
        else
            # echo $@[$#] exists
        fi
    fi

    # for i in {1..${#@}}; do
    #     echo $i, $@[$i]
    # done
    echo secure copy : $flist
    echo to: $remotehost:$remotedir
    scp $flist $remotehost:$remotedir/
}

function manuscp() {
    remotedir="/home/thomas/public_html/manuscript"
    remotehost="thomas@opentech.meinserver.at"
    flist=$@
    if [[ $# -gt 1 ]]; then
        # echo more than one arg:  $#
        if [[ ! -e $@[$#] ]]; then
            # echo last arg $@[$#] does not exist
            # echo strip it from arglist
            strippedlen=$((${#@}-1))
            # echo $strippedlen
            # echo ${@:1:${strippedlen}}
            flist=${@:1:${strippedlen}}
            remotedir=$remotedir/$@[${#@}]
            echo $remotehost "mkdir -p $remotedir"
            ssh $remotehost "mkdir -p $remotedir"
        else
            # echo $@[$#] exists
        fi
    fi

    # for i in {1..${#@}}; do
    #     echo $i, $@[$i]
    # done
    echo secure copy : $flist
    echo to: $remotehost:$remotedir
    scp $flist $remotehost:$remotedir/
}

function pastie {
    url=$(curl http://pastie.caboo.se/pastes/create \
  -H "Expect:" \
  -F "paste[parser]=plain_text" \
  -F "paste[body]=<-" \
  -F "paste[authorization]=burger" \
  -s -L -o /dev/null -w "%{url_effective}")
    echo -n "$url" | xclip
    echo "$url"
}

extract_archive () {
    local old_dirs current_dirs lower
    lower=${(L)1}
    old_dirs=( *(N/) )
    if [[ $lower == *.tar.gz || $lower == *.tgz ]]; then
        tar xvzf $1
    elif [[ $lower == *.gz ]]; then
        gunzip $1
    elif [[ $lower == *.tar.bz2 || $lower == *.tbz ]]; then
        tar xvjf $1
    elif [[ $lower == *.bz2 ]]; then
        bunzip2 $1
    elif [[ $lower == *.zip ]]; then
        unzip $1
    elif [[ $lower == *.rar ]]; then
        unrar e $1
    elif [[ $lower == *.tar ]]; then
        tar xvf $1
    elif [[ $lower == *.lha ]]; then
        lha e $1
    else
        print "Unknown archive type: $1"
        return 1
    fi
    # Change in to the newly created directory, and
    # list the directory contents, if there is one.
    current_dirs=( *(N/) )
    for i in {1..${#current_dirs}}; do
        if [[ $current_dirs[$i] != $old_dirs[$i] ]]; then
            cd $current_dirs[$i]
            break
        fi
    done
}

roll () {
    FILE=$1
    case $FILE in
        *.tar.bz2) shift && tar cjf $FILE $* ;;
        *.tar.gz) shift && tar czf $FILE $* ;;
        *.tgz) shift && tar czf $FILE $* ;;
        *.zip) shift && zip $FILE $* ;;
        *.rar) shift && rar $FILE $* ;;
    esac
}

function mkcd() { mkdir "$1" && cd "$1"; }
function hex2dec { awk 'BEGIN { printf "%d\n",0x$1}'; }
function dec2hex { awk 'BEGIN { printf "%x\n",$1}'; }

function mkmine() { sudo chown -R ${USER} ${1:-.}; }
# sanitize - set file/directory owner and permissions to normal values (644/755)
# Usage: sanitize <file>
function sanitize() {
    chmod -R u=rwX,go=rX "$@"
    chown -R ${USER}.users "$@"
}

function calculeer() { echo "$@" | bc }

function git_info {
    local g="$(git rev-parse --git-dir 2>/dev/null)"
    if [ -n "$g" ]; then
  local r
  local b
  if [ -d "$g/../.dotest" ]
  then
            if test -f "$g/../.dotest/rebasing"
            then
    r="|REBASE"
            elif test -f "$g/../.dotest/applying"
            then
    r="|AM"
            else
    r="|AM/REBASE"
            fi
            b="$(git symbolic-ref HEAD 2>/dev/null)"
  elif [ -f "$g/.dotest-merge/interactive" ]
  then
            r="|REBASE-i"
            b="$(cat "$g/.dotest-merge/head-name")"
  elif [ -d "$g/.dotest-merge" ]
  then
            r="|REBASE-m"
            b="$(cat "$g/.dotest-merge/head-name")"
  elif [ -f "$g/MERGE_HEAD" ]
  then
            r="|MERGING"
            b="$(git symbolic-ref HEAD 2>/dev/null)"
  else
            if [ -f "$g/BISECT_LOG" ]
            then
    r="|BISECTING"
            fi
            if ! b="$(git symbolic-ref HEAD 2>/dev/null)"
            then
    if ! b="tag: $(git describe --exact-match HEAD 2>/dev/null)"
    then
        b="$(cut -c1-7 "$g/HEAD")..."
    fi
            fi
  fi

  if [ -n "$1" ]; then
            printf "$1" "${b##refs/heads/}$r"
  else
            printf "[%s]" "${b##refs/heads/}$r"
  fi
    fi
}
#compdef '_files -g "*.gz *.tgz *.bz2 *.tbz *.zip *.rar *.tar *.lha"' extract_archive

function mgg() {
    (cd ~psc; GIT_PAGER=cat gg $*; cd ~tol; GIT_PAGER=cat gg $*) | less
}


function cfbench() {
    echo time mpirun -np 4 calc_cfbasis -f cfbench.xml -k 30.0 -o oidatest
    time mpirun -np 4 calc_cfbasis -f cfbench.xml -k 30.0 -o oidatest -log_summary | tee logsumm.log
}
function cfmatlab() {
    #TODO aendere den path s.d. matlab die single core version von der cffemlib verwendet
    (
    if [ `hostname` = "thisch" ]; then
        PRELOADSTRING="/usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/lib/x86_64-linux-gnu/libgfortran.so.3"
    else
        PRELOADSTRING=""
    fi
    export PATH=$CFBD:$PATH
    echo env LD_PRELOAD="$PRELOADSTRING" $MATLAB_BIN/matlab -desktop
    env LD_PRELOAD="$PRELOADSTRING" $MATLAB_BIN/matlab -desktop

    )
}

function ipycomp() {
    (enconda &&
     workon py3k &&
     echo `python --version` &&
     cd ${GITR}/ipython &&
     git pull && pi)
}

function genpasswd() {
    tmp=$1
    echo $tmp
    [ "$tmp" = "" ] && tmp=16
    tr -dc "A-Za-z0-9_!@=" < /dev/urandom | head -c ${tmp} | xargs
}
